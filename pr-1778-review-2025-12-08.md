# PR Review: New upload format for webrtc file

**PR Number**: #1778
**Author**: digaobarbosa (Rodrigo Barbosa)
**Branch**: `new-upload-format` → `main`
**URL**: https://github.com/roboflow/inference/pull/1778
**Review Date**: 2025-12-08
**Reviewer**: Claude Code

---

## Summary

This PR implements a new video file upload format for WebRTC workers, introducing a chunked binary protocol for uploading video files via data channels. The implementation adds protocol handlers, state management, and automatic processing triggers when uploads complete.

---

## Changes Overview

**Files Changed**: 4
**Lines Added**: 236
**Lines Deleted**: 16

### Changed Files

- `inference/core/interfaces/webrtc_worker/entities.py` - Added video upload entities and enums
- `inference/core/interfaces/webrtc_worker/utils.py` - Added video chunk parsing utility and quota checking
- `inference/core/interfaces/webrtc_worker/watchdog.py` - Added quota monitoring to watchdog
- `inference/core/interfaces/webrtc_worker/webrtc.py` - Implemented VideoFileUploadHandler and protocol integration

---

## PR Description

> # Description
>
> New upload format for video files.
>
> ## Type of change
>
> - [X] New feature (non-breaking change which adds functionality)
>
> ## How has this change been tested, please provide a testcase or example of how you tested the change?
>
> locally
>
> ## Any specific deployment considerations
>
> For example, documentation changes, usability, usage/costs, secrets, etc.
>
> ## Docs
>
> - [ ] Docs updated? What were the changes:

---

## Analysis

### Purpose & Implementation

**Problem**: The PR implements a new binary protocol for uploading video files via WebRTC data channels to enable processing uploaded videos through workflows.

**Implementation**:
- Binary chunked upload protocol with 8-byte header: `[chunk_index:u32][total_chunks:u32][payload]`
- State machine for upload lifecycle: IDLE → UPLOADING → COMPLETE → PROCESSING → ERROR
- Automatic triggering of video processing when all chunks are received
- Integration with existing WebRTC infrastructure for both video track and data-only modes
- Usage quota checking via watchdog

### Architecture & Design

**Upload Protocol Design**:
- Uses a simple binary header format for chunk metadata
- Reassembles chunks in memory then writes to temp file
- Auto-completes upload when all chunks received - no explicit completion signal needed
- Atomic state transitions prevent duplicate processing

**Integration Points**:
1. **VideoFileUploadHandler** (webrtc.py:144-220): Core upload logic with state management
2. **parse_video_file_chunk** (utils.py:193-201): Binary protocol parsing
3. **Watchdog** (watchdog.py): Enhanced to check quota during processing
4. **Data Channel Handlers** (webrtc.py:1076-1110): Protocol integration

**State Management**:
- Clean separation between upload and processing states
- `try_start_processing()` ensures atomic transition to prevent race conditions
- Proper cleanup with temp file deletion

### Code Quality

**Strengths**:
- Clear separation of concerns (handler, parser, protocol)
- Good use of type hints and enums
- Proper async/await patterns
- Memory efficient chunking (clears chunks after writing to file)

**Concerns**:
1. **Missing error handling in critical paths**:
   - `_write_to_temp_file()` (webrtc.py:182-197) has no exception handling - file write failures will crash
   - Missing chunk index validation (gaps/duplicates)
   - No handling for chunk size mismatches

2. **Resource leaks**:
   - Temp file cleanup only in `cleanup()` - if process crashes, files accumulate
   - No maximum upload size limit - memory exhaustion risk
   - `_chunks` dict unbounded - malicious client could send infinite unique chunks

3. **Protocol robustness**:
   - No checksum/validation of reassembled data
   - No timeout for incomplete uploads
   - Missing chunk ordering validation (assumes client sends in order)

4. **Quota checking issues**:
   - Watchdog quota check (watchdog.py:52) only checks periodically, not before accepting uploads
   - Initial quota check in `__init__.py:44-46` happens too late (after Modal spawn)

### Testing

**Issues**:
- PR description says "tested locally" but provides no test case
- No unit tests added for the new functionality
- No integration tests for the upload protocol
- Missing test coverage for:
  - Chunked upload/reassembly
  - State transitions
  - Error conditions (partial upload, corrupt chunks, quota exceeded)
  - Temp file cleanup

### Potential Issues & Concerns

#### Critical Issues:

1. **Resource Exhaustion** (webrtc.py:154):
   ```python
   self._chunks: Dict[int, bytes] = {}
   ```
   No size limit on chunks dict - malicious client can exhaust memory

2. **No File Write Error Handling** (webrtc.py:182-197):
   ```python
   def _write_to_temp_file(self) -> None:
       import tempfile
       total_size = 0
       with tempfile.NamedTemporaryFile(mode="wb", suffix=".mp4", delete=False) as f:
           # No try/except - will crash on disk full, permissions, etc.
   ```

3. **Quota Check Timing** (watchdog.py:52 & __init__.py:44):
   - Quota checked after Modal function spawned and periodically during processing
   - Should check BEFORE accepting upload to avoid wasted resources

4. **Missing Chunk Validation**:
   ```python
   def handle_chunk(self, chunk_index: int, total_chunks: int, data: bytes) -> None:
       if self._total_chunks is None:
           self._total_chunks = total_chunks
       self._chunks[chunk_index] = data  # No validation!
   ```
   Issues:
   - Doesn't verify chunk_index < total_chunks
   - Doesn't detect gaps in chunks
   - Allows duplicate chunks to overwrite
   - No check if total_chunks changes between messages

5. **Temp File Orphaning**:
   - Cleanup only in `cleanup()` method (webrtc.py:210-219)
   - If process crashes/killed, temp files left in `/tmp`
   - Should use `delete=True` and track file handle OR register cleanup handler

#### Important Issues:

6. **Progress Logging Inefficiency** (webrtc.py:173-174):
   ```python
   if chunk_index % 100 == 0:
       logger.info(f"Upload progress: {len(self._chunks)}/{total_chunks} chunks")
   ```
   Should log based on percentage, not arbitrary modulo

7. **Missing Protocol Version**:
   - Binary protocol has no version field
   - Future protocol changes will break compatibility

8. **Quota Check Implementation** (utils.py:230-237):
   ```python
   def is_over_quota(api_key: str) -> bool:
       api_key_plan_details = usage_collector._plan_details.get_api_key_plan(
           api_key=api_key
       )
       is_over_quota = api_key_plan_details.get(
           usage_collector._plan_details._over_quota_col_name
       )
       return is_over_quota
   ```
   - Accesses private members (`_plan_details`, `_over_quota_col_name`)
   - Could break with internal API changes
   - Should have proper public API or at least helper method

9. **Keepalive Handling Unclear** (webrtc.py:1091-1094):
   ```python
   # Ignore keepalive pings (1-byte messages)
   if len(message) <= 1:
       channel.send(message)
       return
   ```
   - Why echo keepalive back?
   - No documentation on keepalive protocol
   - Magic number (1 byte) should be constant

### Dependencies

No new dependencies added (good).

---

## Recommendations

### Must Fix (Blocking Issues)

1. **Add resource limits**:
   ```python
   MAX_CHUNKS = 10000  # ~480MB at 48KB/chunk
   MAX_UPLOAD_SIZE = 500 * 1024 * 1024  # 500MB

   def handle_chunk(self, chunk_index: int, total_chunks: int, data: bytes):
       if total_chunks > MAX_CHUNKS:
           raise ValueError(f"Upload too large: {total_chunks} chunks")
       if sum(len(c) for c in self._chunks.values()) > MAX_UPLOAD_SIZE:
           raise ValueError("Upload size exceeded")
   ```

2. **Add chunk validation**:
   ```python
   def handle_chunk(self, chunk_index: int, total_chunks: int, data: bytes):
       if self._total_chunks is not None and total_chunks != self._total_chunks:
           raise ValueError("total_chunks mismatch")
       if chunk_index >= total_chunks or chunk_index < 0:
           raise ValueError(f"Invalid chunk_index: {chunk_index}/{total_chunks}")
       if chunk_index in self._chunks:
           logger.warning(f"Duplicate chunk {chunk_index}")
   ```

3. **Add error handling to file write**:
   ```python
   def _write_to_temp_file(self) -> None:
       try:
           with tempfile.NamedTemporaryFile(mode="wb", suffix=".mp4", delete=False) as f:
               # ... write chunks ...
           self._temp_file_path = f.name
       except OSError as e:
           self._state = VideoFileUploadState.ERROR
           logger.error(f"Failed to write temp file: {e}")
           raise
   ```

4. **Fix temp file cleanup** - Use context manager or register cleanup:
   ```python
   import atexit

   def __init__(self):
       # ...
       atexit.register(self.cleanup)
   ```

5. **Add tests** - At minimum:
   - Unit test for `parse_video_file_chunk`
   - Unit test for `VideoFileUploadHandler` state machine
   - Integration test for full upload → process flow
   - Error case tests (partial upload, corrupt chunks, quota exceeded)

6. **Move quota check earlier** - Check before accepting first chunk:
   ```python
   def handle_chunk(self, chunk_index: int, total_chunks: int, data: bytes):
       if chunk_index == 0 and WEBRTC_MODAL_USAGE_QUOTA_ENABLED:
           if is_over_quota(self._api_key):
               raise CreditsExceededError("API key over quota")
   ```

### Should Fix (Important Issues)

7. **Add protocol documentation** - Document the binary protocol format in a docstring or separate doc

8. **Add upload timeout** - Cancel incomplete uploads after reasonable time:
   ```python
   UPLOAD_TIMEOUT = 300  # 5 minutes

   def __init__(self):
       self._upload_started_at: Optional[datetime] = None

   def handle_chunk(...):
       if self._upload_started_at is None:
           self._upload_started_at = datetime.now()
       elif (datetime.now() - self._upload_started_at).seconds > UPLOAD_TIMEOUT:
           raise TimeoutError("Upload timeout")
   ```

9. **Use public API for quota** - Don't access private members:
   ```python
   # In usage_tracking module, add:
   def is_api_key_over_quota(api_key: str) -> bool:
       """Public API for checking quota."""
       # Implementation
   ```

10. **Extract magic constants**:
    ```python
    KEEPALIVE_MESSAGE_SIZE = 1
    VIDEO_CHUNK_PROGRESS_LOG_INTERVAL = 100
    ```

### Nice to Have (Suggestions)

11. **Add checksum validation** - Prevent corrupt uploads:
    ```python
    # Add to header: [chunk_index:u32][total_chunks:u32][crc32:u32][payload]
    ```

12. **Improve progress logging** - Use percentage instead of modulo:
    ```python
    progress_pct = (len(self._chunks) / total_chunks) * 100
    if progress_pct % 10 < (1 / total_chunks * 100):  # Every 10%
        logger.info(f"Upload progress: {progress_pct:.0f}%")
    ```

13. **Add metrics/telemetry**:
    - Track upload sizes
    - Track upload times
    - Track failure rates

14. **Consider streaming write** - Instead of buffering all chunks in memory:
    ```python
    # Write chunks to file as they arrive (requires ordered delivery)
    ```

---

## Deployment Considerations

1. **Environment Variable**: New `WEBRTC_MODAL_USAGE_QUOTA_ENABLED` - ensure it's set in production
2. **Temp File Space**: Video uploads will use `/tmp` - ensure sufficient disk space on Modal containers
3. **Modal Timeout**: Large video uploads may hit Modal timeout - consider increasing for this feature
4. **Quota System**: Depends on usage tracking system being properly configured
5. **Breaking Change Risk**: Low - this is additive functionality, but quota checking might block existing users if misconfigured

---

## Overall Assessment

**Recommendation**: ⚠️ **REQUEST CHANGES**

**Reasoning**:
The PR implements valuable functionality (video file upload via WebRTC) with a clean architecture and good separation of concerns. However, it has **critical resource exhaustion and error handling issues** that could lead to:
- Memory exhaustion from malicious clients
- Disk filling from orphaned temp files
- Crashes from unhandled file I/O errors
- Quota bypass by checking too late

The lack of tests is also concerning for such a complex protocol implementation.

**Confidence Level**: **High**

The code review identifies clear, specific issues that need to be addressed before merging. The implementation is well-structured but needs defensive programming for production use.

---

## Additional Notes

### Code Style
- Good use of type hints and modern Python patterns
- Logging is thorough and helpful for debugging
- Async/await usage is correct

### Performance Consideration
- Codeflash bot found 27% optimization opportunity for `parse_video_file_chunk` (#1779)
- Consider merging the performance improvement

### Protocol Design
The binary protocol is simple and effective, but consider:
- Adding version field for future compatibility
- Adding checksums for data integrity
- Documenting the protocol specification

### Related Work
This appears to be part of a larger effort to support video file processing in WebRTC workflows. Ensure coordination with:
- Frontend changes for uploading files
- API documentation updates
- Usage tracking/billing updates
