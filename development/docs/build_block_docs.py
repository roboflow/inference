import inspect
import json
import os
import re
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Type

from jinja2 import Environment, FileSystemLoader

from inference.core.utils.file_system import dump_text_lines, read_text_file
from inference.core.workflows.execution_engine.entities.base import OutputDefinition
from inference.core.workflows.execution_engine.entities.types import (
    STEP_AS_SELECTED_ELEMENT,
)
from inference.core.workflows.execution_engine.introspection.blocks_loader import (
    describe_available_blocks,
)
from inference.core.workflows.execution_engine.introspection.connections_discovery import (
    discover_blocks_connections,
)
from inference.core.workflows.execution_engine.introspection.entities import (
    BlockDescription,
    BlockManifestMetadata,
    SelectorDefinition,
)
from inference.core.workflows.execution_engine.introspection.schema_parser import (
    parse_block_manifest,
)
from inference.core.workflows.prototypes.block import WorkflowBlock

template_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "templates")
jinja_env = Environment(loader=FileSystemLoader(template_dir))

def render_template(template_name, **kwargs):
    template = jinja_env.get_template(template_name)
    return template.render(**kwargs)

DOCS_ROOT_DIR = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        "..",
        "..",
        "docs",
    )
)

BLOCKS_DIR = os.path.join(DOCS_ROOT_DIR, "workflows", "blocks")

BLOCK_DOCUMENTATION_FILE = os.path.join(DOCS_ROOT_DIR, "workflows", "blocks", "index.md")

KINDS_DIR = os.path.join(DOCS_ROOT_DIR, "workflows", "kinds")
KINDS_DOCUMENTATION_TEMPLATE = os.path.join(DOCS_ROOT_DIR, "workflows", "kinds_template.md")
KINDS_DOCUMENTATION_FILE = os.path.join(DOCS_ROOT_DIR, "workflows", "kinds", "index.md")

BLOCK_DOCUMENTATION_DIRECTORY = os.path.join(DOCS_ROOT_DIR, "workflows", "blocks")
KINDS_DOCUMENTATION_DIRECTORY = os.path.join(DOCS_ROOT_DIR, "workflows", "kinds")
AUTOGENERATED_KINDS_LIST_TOKEN = "<!--- AUTOGENERATED_KINDS_LIST -->"

USER_CONFIGURATION_HEADER = [
    "| **Name** | **Type** | **Description** | Refs |",
    "|:---------|:---------|:----------------|:-----|",
]

BLOCK_FAMILY_TEMPLATE = """
# {family_name}

{content}
"""

BLOCK_VERSION_TEMPLATE = """
{description}

### Type identifier

Use the following identifier in step `"type"` field: `{type_identifier}`to add the block as
as step in your workflow.

### Properties

{block_inputs}

The **Refs** column marks possibility to parametrise the property with dynamic values available 
in `workflow` runtime. See *Bindings* for more info.

### Available Connections {{ data-search-exclude }}

??? tip "Compatible Blocks"
    Check what blocks you can connect to `{family_name}` in version `{version}`.

    - inputs: {input_connections}
    - outputs: {output_connections}

    
### Input and Output Bindings

The available connections depend on its binding kinds. Check what binding kinds 
`{family_name}` in version `{version}`  has.

???+ tip "Bindings"

    - input
    
{block_input_bindings}

    - output
    
{block_output_bindings}



??? tip "Example JSON definition of step `{family_name}` in version `{version}`"

    ```json
    {example}
    ```

<style>
/* hide edit button for generated pages */
article > a.md-content__button.md-icon:first-child {{
    display: none;
}}
</style>    
"""



BLOCK_VERSION_TEMPLATE_SINGLE_VERSION = """

??? "Class: `{short_block_class_name}`"

    Source:
    <a target="_blank" href="{block_source_link}">{block_class_name}</a>
    

""" + BLOCK_VERSION_TEMPLATE


BLOCK_VERSION_TEMPLATE_MULTIPLE_VERSIONS = """

## {version}

??? "Class: `{short_block_class_name}`  *(there are multiple versions of this block)*"

    Source:
    <a target="_blank" href="{block_source_link}">{block_class_name}</a>

    **Warning: This block has multiple versions. Please refer to the specific version for details.**
    You can learn more about how versions work here: [Versioning](/workflows/versioning.md)

    

""" + BLOCK_VERSION_TEMPLATE

BLOCK_CARD_TEMPLATE = '<p class="card block-card" data-url="{data_url}" data-name="{data_name}" data-desc="{data_desc}" data-labels="{data_labels}" data-author="{data_authors}"></p>\n'

DATA_REPRESENTATION_WARNING = """
!!! Warning "Data representation"

    This kind has a different internal and external representation. **External** representation is relevant for 
    integration with your workflow, whereas **internal** one is an implementation detail useful for Workflows
    blocks development.

"""

KIND_PAGE_TEMPLATE = """
# `{kind_name}` Kind

{description}

## Data representation

{data_representation_warning}

### External

External data representation is relevant for Workflows clients - it dictates what is the input and output format of
data.

Type: `{serialised_data_type}`

### Internal

Internal data representation is relevant for Workflows blocks creators - this is the type that will be provided
by Execution Engine in runtime to the block that consumes input of this kind.

Type: `{internal_data_type}`

## Details

{details}

<style>
/* hide edit button for generated pages */
article > a.md-content__button.md-icon:first-child {{
    display: none;
}}
</style>
"""

INLINE_UQL_PARAMETER_PATTERN = re.compile(r"({{\s*\$parameters\.(\w+)\s*}})")

BLOCK_SECTIONS = [
        {
            "title": "Models",
            "id": "model",
            "colorScheme": "purboflow"
        },
        {
            "title": "Visualizations",
            "id": "visualization",
            "colorScheme": "blue"
        },
        {
            "title": "Logic and Branching",
            "id": "flow_control",
            "colorScheme": "yellow"
        },
        {
            "title": "Data Storage",
            "id": "data_storage",
            "colorScheme": "pink"
        },
        {
            "title": "Notifications",
            "id": "notifications",
            "colorScheme": "salmon"
        },
        {
            "title": "Transformations",
            "id": "transformation",
            "colorScheme": "green"
        },
        {
            "title": "Classical Computer Vision",
            "id": "classical_cv",
            "colorScheme": "cyan"
        },
        {
            "title": "Video",
            "id": "video",
            "colorScheme": "indigo"
        },
        {
            "title": "Advanced",
            "id": "advanced",
            "colorScheme": "orange"
        }
    ]


def main() -> None:
    blocks_description = describe_available_blocks(dynamic_blocks=[])
    write_kinds_docs(blocks_description)
    write_blocks_docs(blocks_description)


def write_blocks_docs(blocks_description):

    # create blocks directory if it doesn't exist
    os.makedirs(BLOCK_DOCUMENTATION_DIRECTORY, exist_ok=True)

    # get block assgined to families    
    block_families = get_block_families(blocks_description)

    # write blocks index file
    write_blocks_index_file(block_families)

    # write blocks summary file
    write_blocks_summary_md(block_families)

    # write individual block pages
    write_individual_block_pages(block_families, blocks_description)
    

def write_individual_block_pages(block_families, blocks_description):
    block_type2manifest_type_identifier = {
        block.block_class: block.human_friendly_block_name
        for block in blocks_description.blocks
    }
    blocks_connections = discover_blocks_connections(
        blocks_description=blocks_description
    )   

    for family_name, family_members in block_families.items():
        
        documentation_file_name = slugify_block_name(family_name) + ".md"
        documentation_file_path = os.path.join(
            BLOCK_DOCUMENTATION_DIRECTORY, documentation_file_name
        )
        
        versions_content = []
        for block in family_members:
            block_class_name = block.fully_qualified_block_class_name
            block_source_link = get_source_link_for_block_class(block.block_class)
            example_definition = generate_example_step_definition(block=block)
            parsed_manifest = parse_block_manifest(manifest_type=block.manifest_class)
            long_description = block.block_schema.get("long_description", "Description not available")


            template = BLOCK_VERSION_TEMPLATE_SINGLE_VERSION if len(family_members) == 1 else BLOCK_VERSION_TEMPLATE_MULTIPLE_VERSIONS

            version_content = template.format(
                family_name=family_name,
                version=block.block_schema.get("version", "undefined"),
                block_source_link=block_source_link,
                block_class_name=block_class_name,
                short_block_class_name = block.fully_qualified_block_class_name.split(".")[-1],
                type_identifier=block.manifest_type_identifier,
                description=long_description,
                block_inputs=format_block_inputs(parsed_manifest),
                block_input_bindings=format_input_bindings(parsed_manifest),
                block_output_bindings=format_block_outputs(block.outputs_manifest),
                input_connections=format_block_connections(
                    connections=blocks_connections.input_connections.block_wise[
                        block.block_class
                    ],
                    block_type2manifest_type_identifier=block_type2manifest_type_identifier,
                ),
                output_connections=format_block_connections(
                    connections=blocks_connections.output_connections.block_wise[
                        block.block_class
                    ],
                    block_type2manifest_type_identifier=block_type2manifest_type_identifier,
                ),
                example=_dump_step_example_definition(example_definition=example_definition),
            )
            versions_content.append(version_content)
        all_versions_combined = combined_content_from_versions(versions_content)
        family_document_content = BLOCK_FAMILY_TEMPLATE.format(
            family_name=family_name,
            content=all_versions_combined,
        )
        with open(documentation_file_path, "w") as documentation_file:
            documentation_file.write(family_document_content)




def get_block_families_by_section(block_families):
    # Group families by block_type
    blocks_by_section = defaultdict(list)
    for family_name, members in block_families.items():
        if not members:
            section = "custom"
        else:
            block_name =  members[0].block_schema.get("name", "Missing Name")
            ui_manifest = members[0].block_schema.get("ui_manifest", {})
            section =  ui_manifest.get("section", "custom")
            if not section:
                section = "custom"
        blocks_by_section[section].append(family_name)

    return blocks_by_section



def write_blocks_summary_md(block_families):
    """
    Creates SUMMARY.md for mkdocs-literate-nav.
    """

    block_families_by_section = get_block_families_by_section(block_families)

    lines = []

    # For each block type, create a top-level bullet, then sub-bullets for families
    for block_section in BLOCK_SECTIONS:
        section_title = block_section['title']
        section_id = block_section['id']
        
        lines.append(f"* {section_title}")
        for family_name in sorted(block_families_by_section[section_id], key=lambda x: block_families[x][0].block_schema.get("ui_manifest", {}).get("blockPriority", 99)):
            # Suppose you had a function slugify_block_name:
            slug = slugify_block_name(family_name)
            # Link to foo.md (or bar.md, etc.)
            lines.append(f"    * [{family_name}]({slug}.md)")

    summary_path = os.path.join(BLOCKS_DIR, "SUMMARY.md")
    with open(summary_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")


def write_blocks_index_file(block_families):

    block_families_by_section = get_block_families_by_section(block_families)
    blocks_by_section = {}

    for block_section in BLOCK_SECTIONS:
        section_title = block_section['title']
        section_id = block_section['id']

        blocks_by_section[section_id] = []
        
        
        for family_name in sorted(block_families_by_section[section_id], key=lambda x: block_families[x][0].block_schema.get("ui_manifest", {}).get("blockPriority", 99)):
            block_schema = block_families[family_name][0].block_schema
            block_data = {
                "name": family_name,
                "url": slugify_block_name(family_name),
                "description": block_schema.get("short_description", "Description not available"),
                "license": block_schema.get("license", "").upper(),
                "icon": block_schema.get("ui_manifest", {}).get("icon", "far fa-sparkles")
            }
            blocks_by_section[section_id].append(block_data)

        
    

    output = render_template("blocks_index.md", blocks_by_section=blocks_by_section, block_sections=BLOCK_SECTIONS)


    with open(BLOCK_DOCUMENTATION_FILE, "w", encoding="utf-8") as f:
        f.write(output)


def get_block_families(blocks_description):
    '''
    Get block families and sort them by version.
    '''
    block_families = defaultdict(list)
    for block in blocks_description.blocks:
        block_families[block.human_friendly_block_name].append(block)
    for family_name, family_members in block_families.items():
        block_families[family_name] = sorted(
            family_members,
            key=lambda block: int(block.block_schema.get("version", "v0")[1:]),
            reverse=True,
        )
    return block_families


def combined_content_from_versions(versions_content: List[str]) -> str:
    return "\n\n".join(versions_content)

def _dump_step_example_definition(example_definition: dict) -> str:
    definition_stringified = "\n\t".join(json.dumps(example_definition, indent=4).split("\n"))
    return INLINE_UQL_PARAMETER_PATTERN.sub(_escape_uql_brackets, definition_stringified)


def _escape_uql_brackets(match: re.Match) -> str:
    content = match.group(0)
    return "{{ '{{' }}" + content[2:-2] + "{{ '}}' }}"


def get_source_link_for_block_class(block_class: Type[WorkflowBlock]) -> str:
    try:
        filename = inspect.getfile(block_class).split("inference/core/workflows/")[1]
        return f"https://github.com/roboflow/inference/blob/main/inference/core/workflows/{filename}"
    except Exception as e:
        return None

def get_auto_generation_markers(
    documentation_lines: List[str],
    token: str,
) -> Tuple[int, int]:
    lines_with_token_indexes = search_lines_with_token(
        lines=documentation_lines, token=token
    )
    if len(lines_with_token_indexes) != 2:
        raise RuntimeError(
            f"Please inject two {AUTOGENERATED_BLOCKS_LIST_TOKEN} "
            f"tokens to signal start and end of autogenerated table."
        )
    return lines_with_token_indexes[0], lines_with_token_indexes[-1]


def search_lines_with_token(lines: List[str], token: str) -> List[int]:
    result = []
    for line_index, line in enumerate(lines):
        if token in line:
            result.append(line_index)
    return result


def build_kind_page_path(kind_name: str) -> str:
    kind_file_name = f"{slugify_kind_name(kind_name=kind_name)}.md"
    return os.path.join(KINDS_DOCUMENTATION_DIRECTORY, kind_file_name)


def slugify_kind_name(kind_name: str) -> str:
    kind_name = re.sub(r"[\[\] ]+", r"_", kind_name.lower())
    kind_name = camel_to_snake(name=kind_name)

    # avoid wildcard expansion; replace "*"" with "wildcard"
    kind_name = kind_name.replace("*", "wildcard")

    return kind_name.strip("_")


def slugify_block_name(name: str) -> str:
    name = re.sub(r"[/\- ]+", r"", name)
    return camel_to_snake(name=name)


def camel_to_snake(name: str) -> str:
    name = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    name = re.sub("([a-z0-9])([A-Z])", r"\1_\2", name)
    return name.lower()


def format_block_inputs(parsed_manifest: BlockManifestMetadata) -> str:
    rows = []
    for input_description in parsed_manifest.primitive_types.values():
        ref_appear = input_description.property_name in parsed_manifest.selectors
        rows.append(
            f"| `{input_description.property_name}` | `{input_description.type_annotation}` | "
            f"{input_description.property_description}. | {'✅' if ref_appear else '❌'} |"
        )
    return "\n".join(USER_CONFIGURATION_HEADER + rows)


def format_input_bindings(parsed_manifest: BlockManifestMetadata) -> str:
    rows = []
    for selector in parsed_manifest.selectors.values():
        kinds_annotation = prepare_selector_kinds_annotation(selector=selector)
        rows.append(
            f"        - `{selector.property_name}` (*{kinds_annotation}*): {selector.property_description}."
        )
    return "\n".join(rows)


def prepare_selector_kinds_annotation(selector: SelectorDefinition) -> str:
    type_annotation_chunks = set()
    for allowed_reference in selector.allowed_references:
        if allowed_reference.selected_element == STEP_AS_SELECTED_ELEMENT:
            type_annotation_chunks.add("step")
            continue
        for kind in allowed_reference.kind:
            relative_link = f"../kinds/{slugify_kind_name(kind_name=kind.name)}.md"
            type_string = f"[`{kind.name}`]({relative_link})"
            type_annotation_chunks.add(type_string)
    type_annotation_str = ", ".join(type_annotation_chunks)
    if len(type_annotation_chunks) > 1:
        return f"Union[{type_annotation_str}]"
    return type_annotation_str


def format_block_outputs(outputs_manifest: List[OutputDefinition]) -> str:
    rows = []

    for output in outputs_manifest:
        if len(output.kind) == 1:
            relative_link = (
                f"../kinds/{slugify_kind_name(kind_name=output.kind[0].name)}.md"
            )
            kind = output.kind[0].name
            description = output.kind[0].description
            rows.append(
                f"        - `{output.name}` ([`{kind}`]({relative_link})): {description}."
            )
        else:
            kind = ", ".join(
                [
                    f"[`{k.name}`](../kinds/{slugify_kind_name(kind_name=k.name)}.md)"
                    for k in output.kind
                ]
            )
            description = " or ".join(
                [f"{k.description} if `{k.name}`" for k in output.kind]
            )
            rows.append(f"        - `{output.name}` (*Union[{kind}]*): {description}.")

    return "\n".join(rows)


def format_block_connections(
    connections: Set[Type[WorkflowBlock]],
    block_type2manifest_type_identifier: Dict[Type[WorkflowBlock], str],
) -> str:
    if len(connections) == 0:
        return "None"
    connections = [
        (
            f"[`{block_type2manifest_type_identifier[connection]}`]"
            f"({slugify_block_name(block_type2manifest_type_identifier[connection])}.md)"
        )
        for connection in connections
    ]
    return ", ".join(connections)


def generate_example_step_definition(block: BlockDescription) -> dict:
    result = {
        "name": "<your_step_name_here>",
        "type": block.manifest_type_identifier,
    }
    for property_name, property_definition in block.block_schema["properties"].items():
        if property_name in result:
            continue
        examples = property_definition.get("examples", [])
        if len(examples) == 0:
            example = "<block_does_not_provide_example>"
        else:
            example = examples[0]
        result[property_name] = example
    return result

def to_title_case(s: str) -> str:
    """
    Convert e.g. 'object_detection' -> 'Object Detection'
    """
    words = re.split(r'[_\s]+', s.lower())
    return " ".join(w.capitalize() for w in words if w)

def write_kinds_summary_md(kinds):
    """
    Creates docs/workflows/kinds/SUMMARY.md for mkdocs-literate-nav.
    """
    lines = []

    for line in sorted(kinds):
        # replace everything including and after the :
        line = re.sub(r':.*$', '', line)

        # replace back ticks
        line = line.replace("`", "")

        # relative links (remove `../kinds/` prefix)
        line = line.replace("../kinds/", "")

        lines.append(line)

    summary_path = os.path.join(KINDS_DIR, "SUMMARY.md")
    with open(summary_path, "w", encoding="utf-8") as f:
        f.write("".join(lines) + "\n")



def write_kinds_docs(blocks_description):
    os.makedirs(KINDS_DOCUMENTATION_DIRECTORY, exist_ok=True)

    generated_kinds_index_lines = []
    for declared_kind in blocks_description.declared_kinds:
        
        description = (
            declared_kind.description
            if declared_kind.description is not None
            else "Not available."
        )
        details = (
            declared_kind.docs if declared_kind.docs is not None else "Not available."
        )
        warning = ""
        if declared_kind.internal_data_type != declared_kind.serialised_data_type:
            warning = DATA_REPRESENTATION_WARNING
        kind_page = KIND_PAGE_TEMPLATE.format(
            kind_name=declared_kind.name,
            description=description,
            details=details,
            data_representation_warning=warning,
            serialised_data_type=declared_kind.serialised_data_type,
            internal_data_type=declared_kind.internal_data_type,
        )
        relative_link = (
            f"../kinds/{slugify_kind_name(kind_name=declared_kind.name)}.md"
        )
        generated_kinds_index_lines.append(
            f"* [`{declared_kind.name}`]({relative_link}): {description}\n"
        )
        kind_file_path = build_kind_page_path(kind_name=declared_kind.name)
        with open(kind_file_path, "w") as documentation_file:
            documentation_file.write(kind_page)
    
    generated_kinds_index_lines = sorted(generated_kinds_index_lines)
    write_kinds_summary_md(generated_kinds_index_lines)

    kinds_index_lines = read_text_file(
        path=KINDS_DOCUMENTATION_TEMPLATE,
        split_lines=True,
    )
    kinds_start_index, kinds_end_index = get_auto_generation_markers(
        documentation_lines=kinds_index_lines,
        token=AUTOGENERATED_KINDS_LIST_TOKEN,
    )
    kinds_index_lines = (
        kinds_index_lines[: kinds_start_index + 1]
        + generated_kinds_index_lines
        + kinds_index_lines[kinds_end_index:]
    )
    dump_text_lines(
        path=KINDS_DOCUMENTATION_FILE,
        content=kinds_index_lines,
        allow_override=True,
        lines_connector="",
    )


def write_blocks_gallery():
    pass

if __name__ == "__main__":
    main()